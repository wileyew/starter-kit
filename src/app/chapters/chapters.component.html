<div class="container-fluid">
  <div class="jumbotron text-center">
    <h1>
      <span translate>APP_NAME</span>
    </h1>
    <p>
      <i></i> <span>These chapters are focused on giving quality engineers, developers, or anyone interesting in developing the skills necessary in order to become excellent software or quality engineers. </span>
<span></span>
    </p>
<div id="toc_container">
  <p class="toc_title">Chapter Contents</p>
    <ul class="toc_list">
  <li>Quality Engineering Main Principles:</li>
<ul>
    <button (click)="scroll('deciding')" id="decidingAutomation" class="scrollLink"> Types of Testing and Creating a Release Test Strategy</button><br>
    <button (click)="scroll('minimumViable')" id="mvpProduct" class="scrollLink">Minimum Viable Product</button><br>
    <button (click)="scroll('releaseDate')" id="release" class="scrollLink">Release Dates</button><br>
    <button (click)="scroll('prioritizedFeatures')" id="prioritization" class="scrollLink">Prioritization of Features</button><br>
    <button (click)="scroll('typesOfAutomationFrameworks')" id="typesOfAutomationFrameworkLabel" class="scrollLink">Types of Automation Frameworks</button><br>
    <button (click)="scroll('testDataAndCicd')" id="testDataLabel" class="scrollLink">Test Data Management and CICD</button><br>
    <button (click)="scroll('perfTesting')" id="performanceLabel" class="scrollLink">Performance Testing</button><br>
    <button (click)="scroll('blazeMeter')" id="blazeMeterLabel" class="scrollLink">Blaze Meter Tutorial</button><br>
    <button (click)="scroll('atdd')" id="atddLabel" class="scrollLink">Automated Test Driven Development (ATDD)</button><br>
    <button (click)="scroll('locators')" id="locatorsLabel" class="scrollLink">Locators</button><br>
    <button (click)="scroll('cucumberFeatureStepPage')" id="cucumberFeatureLabel" class="scrollLink">Cucumber Feature, Step Defition, and Page Objects</button><br>
    <button (click)="scroll('whenToAutomate')" id="whenToAutomateLabel" class="scrollLink">When Should You Automate You Automate Your Stories?</button><br>
    <button (click)="scroll('futureOfAutomation')" id="futureOfAutomationLabel" class="scrollLink">What is the Future of Automation?</button><br>
  </ul>
</ul>
</div>
<div class="chapter_contents">
    <h5 id="deciding">{{decidingTwo}}</h5>
    <p>To be clear, there are various types of tests that a quality engineer needs to be familiar with.
      When I started as a quality engineer, I literally looked up all the different types of tests that are applicable, however I found this
      <a href="http://www.softwaretestinghelp.com/types-of-software-testing/">site</a> to be the most comprehensive available for learning the different types of functional testing.
      Also, most teams will require a release test strategy for the web application they will be releasing to production.
      A release test strategy typically involves planning with a product spec review and then creating a release plan along with an estimate of the release date.
      The following information is what I would typically include in your release test strategy:<br></p>
<ul type="disc">
<li>Determine the release date of your minimal viable product that will go into production with your scrum team.</li>
<li>Determine the features that your team would like to prioritize together. </li>
<li>Discuss with your team on the framework for automation you'd prefer to use. </li>
<li>Test Data Management and CICD process </li>
<li>Performance Testing for the application, UI as well as API</li>
<li> End to end automation testing </li>
<li>Sign off on release strategy from your product owner as well as upper management. </li>
</ul>
<p>
  I know you are looking at this list and saying to yourself, is this really doable?? Yes, it is and don't worry we will break down the aspects of this madness bullet by bullet!
</p>
<div id="minimumViable" class="chapters-subheadings">
  {{mvp}}
</div>
<p>
  Every team must determine the minimal viable product that they want to ship to either internal or external customer.
  Every team member must coordinate with their teams to determine the release dates for the products they will ship to production.
  As you self organize with your team, the main topics to address are:
  1. Has enough value that people are willing to use it or buy it initially.
  2. Demonstrates enough future benefit to retain early adopters.
  3. Provides a feedback loop to guide future development.
</p>

<div id="releaseDate" class="chapters-subheadings">{{releaseDate}}</div>
<p>
As a quality enginner, or any role on a product development team, there is knowledge needed to be aware of the plans or estimates that your team will be comitting to as well as
when your product will actually be shipped to the end customer! I found a great <a href="https://pm.stackexchange.com/questions/16372/how-do-you-schedule-delivery-dates-in-scrum">article</a> that explains the process of how release dates are calculated.
</p>
<div id="prioritizedFeatures" class="chapters-subheadings">{{prioritizationOfFeatures}}  </div>
<p>
Features must be prioritized by your product owner who controls the intent that will be worked on by the team. The team
then has weekly grooming sessions thereafterwards to make sure they are working on stories that have clearly defined
acceptance criteria that breaks down a story into deliverable behavior that the user of the product would normally utilize. For more information please refer to <a href="https://agilevelocity.com/product-owner/5-factors-to-help-prioritize-your-scrum-product-backlog/"> agile velocity</a> which is a great resource on everything agile!
</p>
<div id="typesOfAutomationFrameworks" class="chapters-subheadings">{{automationFrameworks}} </div>
<p>
  One of the most important questions that quality engineers must consider is the type of test automation framework their team would like to use. I have found this resource helpful in determining which automation framework to use!
</p>
<div class="chapters-video">
<iframe src="//youtube.com/embed/3hHL-BhBW4I" frameborder="0" allowfullscreen width="600" height="400"></iframe>
</div>
<br>
<div id="frameworkLanguage" class= "chapters-subheadings">{{languageFrameworks}} </div>
<p>
  One of the biggest decisions that a team will collectively make is the language that they utilize for their test automation. In my own personal opinion, it is important that teams choose the language
  of their automation framework based upon what they are comfortable with. For example, if a team is utilizing angular javascript for the web application, then it would be important for team members to choose
  javascript automation framework since it would be the same language as their web application. Glowtouch technologies has a great<a href="https://www.glowtouch.com/blog/testing/how-to-choose-the-right-test-automation-framework/"> article  </a>where they break down the different factors that lead to deciding on the most ideal test automation framework for your team!
</p>
<div id="testDataAndCicd" class="chapters-subheadings">{{testDataCicd}}</div>
<p>
  Informatica has a great <a href="https://blogs.informatica.com/2016/06/17/the-importance-of-test-data-management-for-devops-part-1/#fbid=msjnI1pGf5A"> article  </a> that explains the importance of maintaining and creating test data both in test environments such as a QA or dev environment as well as production!
  Once clean test data has been introduced for specific test environments for QA and DEV, it's important to implement a continuous testing solution into your own organization. Sauce labs has a great <a href="https://saucelabs.com/blog/you-cant-do-cicd-without-automated-testing"> article  </a>explaining the significance of test automation within the CICD process and various possible CICD solutions to implement within your own organization.
  Personally, I have in the past used Jenkins 2.0 as an enterprise product that allows us to implement CICD within our own organization.

  Below is the process that I have implemented in the past for CICD within the Capital One organization:
  1. Identify tests that will be tagged as smoke or regression tests and tag them with either @smoke, @regression, or assign a feature tag. Tag will be used by job to run those specific tests within the pipeline.
  2. Create a smoke job that will run sanity checks to verify that your application is sufficiently up and running.
  3. Create a regression job that will ensure that the critical functionalities of your web application are behaving as expected.
  4. Schedule the smoke job to run on a morning basis. I normally have our smoke jobs running when I get into the office, around 8-9AM.
  5. Schedule the regression job to be run on at least a weekly basis. This will also allow you to identify defects within the application that you would not have normally tested.
  6. Hook your test automation jobs to the delivery pipeline that developers utilize. For example, if code is merged and then successfully deployed to either the QA or dev environments, then create a pipeline that kicks off the smoke test automation.
  7. If your smoke test automation passes, then the code newly release is then tagged as a candidate for QA and is then released into the QA environment.

  Every organization has a responsibility for quality code, ensure that you discuss your CICD strategy with the entire team to get appropriate feedback and developing a viable solution.
</p>
<div id="perfTesting" class="chapters-subheadings">{{perfTesting}} </div>
<p>
  In order to performance test your application, there are multiple concepts that are important to understand first. The first
  part of the implementation of solid performance testing is to understand the transactions per second that an application must be capable of handling.
  The product owner for your team, or the person from your team handling the business side of your application must understand the transactions per second an application must handle.
  Once the desired transactions per second is determined by your product owner, it is important to do stress testing or load testing of the web application. This will allow the user to determine the maximum load a web application can withstand.
</p>
<div id="blazeMeter" class="chapters-subheadings">{{blazemeter}} </div>
<p>
Blazemeter is a tool that allows you to create performance test scripts in your UI. By using the Blazemeter plugin,
you are able to record by naming a test script with the chrome plugin, stop the recording when the flow of the UI performance script
has been completed. You can then export the completed blazemeter file into a jmx file and modify the jmx file based upon the performance script flow.
Below is an example tutorial of how to create a UI performance script using Blazemeter:
</p>

<div id="atdd" class="chapters-subheadings">{{atdd}}</div>
<p>
Automated Test Driven Development is a practice where anyone on a team, either a developer or a QA person, creates automated test scripts
 that validates the functionality of a particular story.
For example, if there is a story for a login page whereby a valid user, who has already registered,
can sign in to a dashboard,then a QA or developer would create a test script that automates the particular functionality.
The automated script first needs to start with gherkin, otherwise known as Given When Then format. Let's go step by step on how to write gherkin by using the example above:<br><br>

Scenario: Validate that an adminstrator can login to the website<br>
Given I am an administrator<br>
When I login to the website<br>
Then I will be able to see the dashboard<br>
And I will be able to see a list of users that are registered on the site<br><br>
The behaviors listed in the scenario above, we can understand the scenario that will be tested. Either the product owner for the team or the scrum master (preferably product owner),

</p>
<div id="locators" class="chapters-subheadings">{{locators}}</div>
<p>
Locators are essential for having stable test automation frameworks. If you do not have good locators within your script, your tests will fail or become brittle over time.
A good example of non brittle locators are scripts that contain unique identifiers are the following:
</p>
<ul>
  <li>Unique id or css name for an element</li>
  <li>If no unique id available then use the relative path double forward slash (//)</li>
  <li>Use a combination of locators such as name, linkText, className, partial link text, and css.</li>
  <li>Avoid absolute xpath!!!</li>
</ul>
<p>
Below is also a video explaining how to use jquery selectors in order to have uniquely identified elements:
</p>
<div class="video-container">
<iframe src="//www.youtube.com/embed/lZnclZzxnFQ" frameborder="0" allowfullscreen width="600" height="400"></iframe>
</div>
<div id="cucumberFeatureStepPage" class="chapters-subheadings"> {{cucumberFeatures}}</div>
<p>
To fully understand this section, please read the section above on ATDD (Automated Test Driven Development.) Let's break down each section:
</p>
<div>Feature file (.feature)</div>
<ul>
  <li>Contains the Given, And, When, Then (otherwise known as gherkin)</li>
  <li>Contains Scenarios that relate back to the feature developed as well as Scenario
    Outlines which give test data inserted within the gherkin which will be used
    as test data or variables within your step definitons and/or page object file.</li>
</ul>
<div>Step Definitions</div>
<ul>
  <li>Mapped directly to the gherkin statement (can be a Given When And or Then statement)</li>
  <li>Contains Scenarios that relate back to the feature developed as well as Scenario
    Outlines which give test data inserted within the gherkin which will be used
    as test data or variables within your step definitons and/or page object file.</li>
</ul>
<div>Page Objects</div>
<ul>
<li>The methods within page objects map directly to the method called within the step defition. For example,
  a step definition could contain a method call named basePage.getUrl().
  This method call would be invoked within the base page and the page object in this case would be the base page.</li>
</ul>
<div>To see the feature, step defintion, and page object modeling in action, please watch the following video:</div>
<br>
<div id="whenToAutomate" class="chapters-subheadings"> {{whenToAutomateStories}} </div>
<p>
  How do we know when to automate stories? Well, there are multiple factors to consider before automating an agile story:
</p>

  <ul>
    <li>Is the story size feasible to be automated?</li>
    <li>Is the story of critical nature to be automated?</li>
    <li>If you are not able to automate the story, can someone on your team automate the story as well as test it?</li>
  </ul>
<p>
  The first question, is the story size feasible to be automated is very important. If the story is too large or complex, it will be difficult to automate within a sprint.
  My suggestion would be to talk to your team about the possibility of breaking down the story into smaller chunks or possibly automating just the critical functionalities
  within the story to sizable chunks.
<br/><br/>
Rating the importance of the scenario to be automated is a huge question to ponder. If you are not able to determine the low medium or high importance of the scenario,
discuss the rating with your scrum team. Usually within test automation, the rule of
thumb would be to automate at least 80% of your medium rated scenarios and 100% of your critical scenarios.
<br/><br/>
If you are not able to automate the story as a QA associate or contractor, there should be someone else on your team that knows how to do test automation. When I was working
with my previous team within Capital One, I trained all of them to do test automation. While I was working on development stories, I was able to cross train them on test
automation. By the time I para programmed with them on a couple of stories for test automation, they were all doing the test automation independently! Not only will it feel great to teach a coworker a new skill
but your team will become efficient and fungible. This reemphasizes the philosophy that we should all know how to automate and tackle development stories!
</p>
<div id="futureOfAutomation" class="chapters-subheadings"> {{futureOfTestAIAutomation}} </div>
<p>
  There are still a lot of unknown factors in regards to artificial intelligence within test automation. The large majority of quality engineers have not ventured into using artificial intelligence for their test automation.
  However, there is still a lot of research that needs to be done in this field in order to have a solid foundation built upon the artificial intelligence field. An <a href='https://www.joecolantonio.com/2017/11/07/7-innovative-ai-test-automation-tools-future-third-wave/'> article</a> from Joe Colantino highlights the budding artificial intelligence frameworks that exist today.
  We must also keep in mind, that artificial intelligence must be used as an enhancement to our testing practices. In my own opinion, artificial intelligence will allow all agile team members and even product owners to design tests that cover both the user interface as well as
  the APIs that interact with their own application. The intelligence that guides the creation of further test automation will be the baseline upon which future tests can be handled as well as intelligently catching errors even an experienced QA member might not even identify!
</p>
